name: CI - Bookstore Inventory API

on:
  push:
    branches: [ main, develop, feature/** ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test_app:
    name: Test Django Application (CI)
    runs-on: ubuntu-latest
    
    env:
      SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
      DB_USER: ${{ secrets.POSTGRES_USER }}
      DB_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      
      DB_NAME: bookstore_db
      DB_HOST: db
      DB_PORT: 5432
      DEBUG: 1
      EXCHANGE_RATE_API_URL: https://api.exchangerate-api.com/v4/latest/USD
      LOCAL_CURRENCY: VES
      PROFIT_MARGIN: 0.40

    steps:
      - name: Checkout Código
        uses: actions/checkout@v4

      # 1. Crea un archivo de override temporal y levanta los contenedores
      - name: Build y Start Docker Compose (con Override de Comando)
        run: |
          # Crea el archivo override que mantiene vivo el contenedor 'web'
          echo 'services:
            web:
              command: /bin/sh -c "while true; do sleep 30; done"' > docker-compose.test_app.yml
          
          # Levanta los servicios usando el archivo principal y el override
          docker compose -f docker-compose.yml -f docker-compose.test_app.yml up --build -d

      # 2. Espera a que PostgreSQL esté lista usando un script de shell
      - name: Esperar a que PostgreSQL esté lista
        run: |
          echo "Esperando a que la base de datos esté lista..."
          max_retries=10
          delay=6
          for i in $(seq 1 $max_retries); do
            # Intenta conectarse a la BD dentro del contenedor 'db'
            if docker compose exec db pg_isready -h localhost -p 5432 -U $DB_USER 2>/dev/null; then
              echo "PostgreSQL está lista."
              exit 0
            fi
            echo "Intento $i de $max_retries. Esperando $delay segundos..."
            sleep $delay
          done
          echo "Error: PostgreSQL no está lista después de múltiples reintentos."
          exit 1
          
      # 3. Aplicar Migraciones
      - name: Aplicar Migraciones
        run: docker compose exec -T --env DB_HOST=$DB_HOST --env DB_PORT=$DB_PORT --env DB_NAME=$DB_NAME --env DB_USER=$DB_USER --env DB_PASSWORD=$DB_PASSWORD --env SECRET_KEY=$SECRET_KEY web python manage.py migrate
        
      # 4. Ejecuta las pruebas unitarias
      - name: Ejecutar Pruebas de Django
        run: docker compose exec -T --env DB_HOST=$DB_HOST --env DB_PORT=$DB_PORT --env DB_NAME=$DB_NAME --env DB_USER=$DB_USER --env DB_PASSWORD=$DB_PASSWORD --env SECRET_KEY=$SECRET_KEY web python manage.py test inventory
      
      # 5. Limpieza
      - name: Detener y Eliminar Contenedores
        if: always() 
        run: docker compose down -v


  build_and_push:
    name: Build & Publish Docker Image (CD)
    runs-on: ubuntu-latest
    needs: test_app
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # 1. Login en el Registro de Docker
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }} 
          password: ${{ secrets.DOCKERHUB_TOKEN }}  

      # 2. Configura los metadatos de la imagen (etiquetas/tags)
      - name: Extract metadata (tags) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/bookstore-inventory-api
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=latest,enable=${{ github.ref == format('refs/heads/{0}', 'main') || github.ref == format('refs/heads/{0}', 'develop') }}

      # 3. Construye y Publica la imagen Docker
      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}