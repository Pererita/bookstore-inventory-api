name: CI - Bookstore Inventory API

on:
  push:
    branches: [ main, develop, feature/** ]
  pull_request:
    branches: [ main, develop ]

jobs:
  ci:
    runs-on: ubuntu-latest
    
    env:
      SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
      DB_USER: ${{ secrets.POSTGRES_USER }}
      DB_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      
      DB_NAME: bookstore_db
      DB_HOST: db
      DB_PORT: 5432
      DEBUG: 1
      EXCHANGE_RATE_API_URL: https://api.exchangerate-api.com/v4/latest/USD
      LOCAL_CURRENCY: VES
      PROFIT_MARGIN: 0.40

    steps:
      - name: Checkout Código
        uses: actions/checkout@v4

      # 1. Inicia la base de datos y construye la aplicación web
      - name: Build y Start Docker Compose
        run: docker compose up --build -d

      # 2. Espera a que PostgreSQL esté lista usando un script de shell
      - name: Esperar a que PostgreSQL esté lista
        run: |
          echo "Esperando a que la base de datos esté lista..."
          max_retries=10
          delay=6
          for i in $(seq 1 $max_retries); do
            # Intenta conectarse a la BD dentro del contenedor 'db'
            if docker compose exec db pg_isready -h localhost -p 5432 -U ${{ secrets.POSTGRES_USER }}; then
              echo "PostgreSQL está lista."
              exit 0
            fi
            echo "Intento $i de $max_retries. Esperando $delay segundos..."
            sleep $delay
          done
          echo "Error: PostgreSQL no está lista después de múltiples reintentos."
          exit 1 # Falla el workflow si la BD no está lista
          
      # 3. Ejecuta las migraciones
      - name: Aplicar Migraciones
        run: docker compose exec web python manage.py migrate
        
      # 4. Ejecuta las pruebas unitarias
      - name: Ejecutar Pruebas de Django
        run: docker compose exec web python manage.py test inventory
      
      # 5. Limpieza
      - name: Detener y Eliminar Contenedores
        if: always() 
        run: docker compose down -v